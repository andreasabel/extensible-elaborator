module Hw2 where

-- show that propositional equality is transitive

trans : (A:Type) -> (x:A) -> (y:A) -> (z:A) -> (x = z) -> (z = y) -> (x = y)
trans = \a x y z e1 e2. subst e2 by e1


-- properties of booleans

-- an encoding of logical falsity
void : Type
void = (A:Type) -> A

neg : Type -> Type
neg = \ A . ( (A) -> void )

not : Bool -> Bool
not = \ x . if x then False else True

-- show that true is not false

not_not_equal : (b : Bool) -> (b = not b) -> void
not_not_equal = \b r. if b then contra r else contra r


not_false_then_true : (b : Bool) -> neg (b = False) -> b = True
not_false_then_true = \b n. if b then (Refl : b = True) else (n (Refl : b = False)) (b = True)

-- show that decidable equality for booleans is correct.

eq_bool : Bool -> Bool -> Bool
eq_bool = \x y. if x then y else not y

eq_true : (b1 : Bool) -> (b2 : Bool) -> eq_bool b1 b2 = True -> (b1 = b2)
eq_true = \b1 b2 pf. if b1
                     then (if b2 then Refl else (contra pf))
                     else (if b2 then (contra pf) else Refl)

eq_false : (b1 : Bool) -> (b2 : Bool) -> eq_bool b1 b2 = False -> (b1 = b2) -> void
eq_false = \b1 b2 pe qe. if b1
                         then (if b2 then (contra pe) else (contra qe))
                         else (if b2 then (contra qe) else (contra pe))

false_eq_bool : (n : Bool) -> (m : Bool) ->
     neg (n = m) ->
     eq_bool n m = False
false_eq_bool = \n m nnm. 