
@article{abelUnifiedViewModalities2020,
  title = {A Unified View of Modalities in Type Systems},
  author = {Abel, Andreas and Bernardy, Jean-Philippe},
  date = {2020-08-02},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {4},
  pages = {90:1--90:28},
  doi = {10.1145/3408972},
  url = {https://doi.org/10.1145/3408972},
  urldate = {2022-07-04},
  abstract = {We propose to unify the treatment of a broad range of modalities in typed lambda calculi. We do so by defining a generic structure of modalities, and show that this structure arises naturally from the structure of intuitionistic logic, and as such finds instances in a wide range of type systems previously described in literature. Despite this generality, this structure has a rich metatheory, which we expose.},
  issue = {ICFP},
  keywords = {linear types,modal logic,subtyping},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Abel_Bernardy/2020/Abel_Bernardy_2020_A unified view of modalities in type systems.pdf}
}

@inproceedings{aspertiCraftingProofAssistant2007,
  title = {Crafting a {{Proof Assistant}}},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  author = {Asperti, Andrea and Coen, Claudio Sacerdoti and Tassi, Enrico and Zacchiroli, Stefano},
  editor = {Altenkirch, Thorsten and McBride, Conor},
  date = {2007},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {18--32},
  publisher = {{Springer}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-540-74464-1_2},
  abstract = {Proof assistants are complex applications whose development has never been properly systematized or documented. This work is a contribution in this direction, based on our experience with the development of Matita: a new interactive theorem prover based—as Coq—on the Calculus of Inductive Constructions (CIC). In particular, we analyze its architecture focusing on the dependencies of its components, how they implement the main functionalities, and their degree of reusability.},
  isbn = {978-3-540-74464-1},
  langid = {english},
  keywords = {Architectural Solution,Level Term,Logical Framework,Proof Assistant,Theorem Prover},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Asperti et al/2007/Asperti et al_2007_Crafting a Proof Assistant.pdf}
}

@article{aspertiUserInteractionMatita2007,
  title = {User {{Interaction}} with the {{Matita Proof Assistant}}},
  author = {Asperti, Andrea and Sacerdoti Coen, Claudio and Tassi, Enrico and Zacchiroli, Stefano},
  date = {2007-08-01},
  journaltitle = {Journal of Automated Reasoning},
  shortjournal = {J Autom Reasoning},
  volume = {39},
  number = {2},
  pages = {109--139},
  issn = {1573-0670},
  doi = {10.1007/s10817-007-9070-5},
  url = {https://doi.org/10.1007/s10817-007-9070-5},
  urldate = {2022-05-23},
  abstract = {Matita is a new, document-centric, tactic-based interactive theorem prover. This paper focuses on some of the distinctive features of the user interaction with Matita, characterized mostly by the organization of the library as a searchable knowledge base, the emphasis on a high-quality notational rendering, and the complex interplay between syntax, presentation, and semantics.},
  langid = {english},
  keywords = {Authoring,Digital libraries,Interactive theorem proving,Mathematical knowledge management,Proof assistant,XML},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Asperti et al/2007/Asperti et al_2007_User Interaction with the Matita Proof Assistant.pdf}
}

@article{changDependentTypeSystems2019,
  title = {Dependent Type Systems as Macros},
  author = {Chang, Stephen and Ballantyne, Michael and Turner, Milo and Bowman, William J.},
  date = {2019-12-20},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {4},
  pages = {3:1--3:29},
  doi = {10.1145/3371071},
  url = {http://doi.org/10.1145/3371071},
  urldate = {2021-06-28},
  abstract = {We present Turnstile+, a high-level, macros-based metaDSL for building dependently typed languages. With it, programmers may rapidly prototype and iterate on the design of new dependently typed features and extensions. Or they may create entirely new DSLs whose dependent type ``power'' is tailored to a specific domain. Our framework's support of language-oriented programming also makes it suitable for experimenting with systems of interacting components, e.g., a proof assistant and its companion DSLs. This paper explains the implementation details of Turnstile+, as well as how it may be used to create a wide-variety of dependently typed languages, from a lightweight one with indexed types, to a full spectrum proof assistant, complete with a tactic system and extensions for features like sized types and SMT interaction.},
  issue = {POPL},
  keywords = {dependent types,macros,proof assistants,type systems},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Chang et al/2019/Chang et al_2019_Dependent type systems as macros2.pdf}
}

@online{coqdevelopmentteamHowWritePlugins,
  title = {How to Write Plugins in {{Coq}}},
  author = {{Coq development team}},
  url = {https://github.com/coq/coq/tree/V8.15.2/doc/plugin_tutorial},
  urldate = {2022-07-15},
  abstract = {In addition to installing OCaml and Coq, you need to make sure that you also have the development headers for Coq, because you will need them to compile extensions. If you installed Coq from source or from OPAM, you already have the required headers. If you installed them from your system package manager, there may be a separate package which contains the development headers (for example, in Ubuntu they are contained in the package libcoq-ocaml-dev). It can help to install several tools for development.},
  langid = {english},
  organization = {{GitHub}}
}

@online{ghcdevelopmentteamGlasgowHaskellCompiler,
  title = {Glasgow {{Haskell Compiler}} 9.2.2 {{User}}'s {{Guide}}: 7. {{Extending}} and Using {{GHC}} as a {{Library}}},
  author = {{GHC development team}},
  url = {https://downloads.haskell.org/ghc/latest/docs/html/users_guide/extending_ghc.html},
  urldate = {2022-07-15}
}

@misc{guidiImplementingTypeTheory2017,
  title = {Implementing {{Type Theory}} in {{Higher Order Constraint Logic Programming}}},
  author = {Guidi, Ferruccio and Coen, Claudio Sacerdoti and Tassi, Enrico},
  date = {2017-11-17},
  url = {https://hal.inria.fr/hal-01410567},
  urldate = {2021-03-24},
  abstract = {In this paper we are interested in high-level programming languages to implement the core components of an interactive theorem prover for a dependently typed language: the kernel — responsible for type-checking closed terms — and the elaborator — that manipulates terms with holes or, equivalently, partial proof terms. In the first part of the paper we confirm that λProlog, the language developed by Miller and Nadathur since the 80s, is extremely suitable for implementing the kernel, even when efficient techniques like reduction machines are employed. In the second part of the paper we turn our attention to the elaborator and we observe that the eager generative semantics inherited by Prolog makes it impossible to reason by induction over terms containing metavariables. We also conclude that the minimal extension to λProlog that allows to do so is the possibility to delay inductive predicates over flexible terms, turning them into (set of) constraints to be propagated according to user provided constraint propagation rules. Therefore we propose extensions to λProlog to declare and manipulate higher order constraints, and we implement the proposed extensions in the ELPI system. Our test case is the implementation of an elaborator for a type theory as a CLP extension to a kernel written in plain λProlog.},
  langid = {english},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Guidi et al/2017/Guidi et al_2017_Implementing Type Theory in Higher Order Constraint Logic Programming.pdf;/home/bohdan/Zotero/storage/LUD3BH7S/hal-01410567v2.html}
}

@misc{henryModularizingGHC,
  title = {Modularizing {{GHC}}},
  author = {Henry, Sylvain and Ericson, John and Young, Jeffrey M},
  url = {https://hsyl20.fr/home/posts/2022-05-03-modularizing-ghc-paper.html},
  abstract = {GHC is the de facto main implementation of the Haskell programming language. Over its year history it has served well the needs of pure functional programmers and researchers alike. However, GHC is not exemplary of good large scale system design in a pure function language. Rather ironically, it violates the properties that draw people to functional programming in the first place: immutability, modularity, and composability. These scars have become more noticeable as modern projects currently underway, such as the Haskell Language Server and cross-compilation, aim to fulfill user needs and desires far more diverse than before. We believe a better GHC is possible. We write this paper to properly situate both the current state of GHC’s codebase and that better future state in the design space of large scale, pure, functional systems. Firstly, we document in detail, GHC’s architectural problems, such as low coherence and high coupling of mutable state, and their genesis. Secondly, we describe what we believe to be a superior design, drawing heavily on domain-driven design principles. Lastly, we sketch a plan to get this design implemented iteratively and durably, mentioning interactions with other ongoing refactorings (structured errors, Trees That Grow, etc.). All of this is informed not just by our own experience working on GHC and deep dives into its history, but also by the traditional software engineering literature. The paper is written from an engineering perspective, with the hope that our collection and recapitulation may provide insight into future best practices for other pure functional software engineers.},
  langid = {english},
  file = {/home/bohdan/Zotero/storage/AEI98ZYD/Henry et al. - Modularizing GHC.pdf}
}

@article{jonesPracticalTypeInference2007,
  title = {Practical Type Inference for Arbitrary-Rank Types},
  author = {Jones, Simon Peyton and Vytiniotis, Dimitrios and Weirich, Stephanie and Shields, Mark},
  date = {2007-01},
  journaltitle = {Journal of Functional Programming},
  volume = {17},
  number = {1},
  pages = {1--82},
  publisher = {{Cambridge University Press}},
  issn = {1469-7653, 0956-7968},
  doi = {10.1017/S0956796806006034},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/practical-type-inference-for-arbitraryrank-types/5339FB9DAB968768874D4C20FA6F8CB6},
  urldate = {2022-06-09},
  abstract = {Haskell's popularity has driven the need for ever more expressive type system features, most of which threaten the decidability and practicality of Damas-Milner type inference. One such feature is the ability to write functions with higher-rank types – that is, functions that take polymorphic functions as their arguments. Complete type inference is known to be undecidable for higher-rank (impredicative) type systems, but in practice programmers are more than willing to add type annotations to guide the type inference engine, and to document their code. However, the choice of just what annotations are required, and what changes are required in the type system and its inference algorithm, has been an ongoing topic of research. We take as our starting point a λ-calculus proposed by Odersky and Läufer. Their system supports arbitrary-rank polymorphism through the exploitation of type annotations on λ-bound arguments and arbitrary sub-terms. Though elegant, and more convenient than some other proposals, Odersky and Läufer's system requires many annotations. We show how to use local type inference (invented by Pierce and Turner) to greatly reduce the annotation burden, to the point where higher-rank types become eminently usable. Higher-rank types have a very modest impact on type inference. We substantiate this claim in a very concrete way, by presenting a complete type-inference engine, written in Haskell, for a traditional Damas-Milner type system, and then showing how to extend it for higher-rank types. We write the type-inference engine using a monadic framework: it turns out to be a particularly compelling example of monads in action. The paper is long, but is strongly tutorial in style. Although we use Haskell as our example source language, and our implementation language, much of our work is directly applicable to any ML-like functional language.},
  langid = {english},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Jones et al/2007/Jones et al_2007_Practical type inference for arbitrary-rank types.pdf}
}

@article{jonesTypeInferenceConstraint2019,
  title = {Type Inference as Constraint Solving: How {{GHC}}’s Type Inference Engine Actually Works},
  shorttitle = {Type Inference as Constraint Solving},
  author = {Jones, Simon Peyton},
  date = {2019-06-15},
  url = {https://www.microsoft.com/en-us/research/publication/type-inference-as-constraint-solving-how-ghcs-type-inference-engine-actually-works/},
  urldate = {2022-06-28},
  abstract = {The Haskell compiler GHC includes a type inference engine for a rather sophisticated type system.~ You might worry that a complicated type system leads to a very complicated type inference engine. ~ You’d be right, but we have learned a lot about how to structure type inference so that the complexity does not get out […]},
  langid = {american},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Jones/2019/Jones_2019_Type inference as constraint solving.pdf;/home/bohdan/Zotero/storage/7PNMILIF/type-inference-as-constraint-solving-how-ghcs-type-inference-engine-actually-works.html}
}

@unpublished{leonardodemouraLeanMetaprogramming2021,
  title = {Lean 4 - Metaprogramming},
  author = {{Leonardo de Moura} and {Sebastian Ullrich}},
  date = {2021-01-06},
  url = {https://leanprover-community.github.io/lt2021/slides/leo-LT2021-meta.pdf},
  urldate = {2022-07-11},
  eventtitle = {Lean Together 2021},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Leonardo de Moura_Sebastian Ullrich/2021/Leonardo de Moura_Sebastian Ullrich_2021_Lean 4 - metaprogramming.pdf;/home/bohdan/Downloads/Dropbox/stuff/papers/Leonardo de Moura_Sebastian Ullrich/2021/Leonardo de Moura_Sebastian Ullrich_2021_Lean 4 - metaprogramming2.pdf}
}

@inproceedings{mouraLeanTheoremProver2021,
  title = {The {{Lean}} 4 {{Theorem Prover}} and {{Programming Language}}},
  booktitle = {Automated {{Deduction}} – {{CADE}} 28},
  author = {de Moura, Leonardo and Ullrich, Sebastian},
  editor = {Platzer, André and Sutcliffe, Geoff},
  date = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {625--635},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-030-79876-5_37},
  abstract = {Lean 4 is a reimplementation of the Lean interactive theorem prover (ITP) in Lean itself. It addresses many shortcomings of the previous versions and contains many new features. Lean 4 is fully extensible: users can modify and extend the parser, elaborator, tactics, decision procedures, pretty printer, and code generator. The new system has a hygienic macro system custom-built for ITPs. It contains a new typeclass resolution procedure based on tabled resolution, addressing significant performance problems reported by the growing user base. Lean 4 is also an efficient functional programming language based on a novel programming paradigm called functional but in-place. Efficient code generation is crucial for Lean users because many write custom proof automation procedures in Lean itself.},
  isbn = {978-3-030-79876-5},
  langid = {english},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Moura_Ullrich/2021/Moura_Ullrich_2021_The Lean 4 Theorem Prover and Programming Language.pdf}
}

@article{najdTreesThatGrow2017,
  title = {Trees That Grow},
  author = {Najd, Shayan and Jones, Simon Peyton},
  date = {2017-01-01},
  journaltitle = {Journal of Universal Computer Science (JUCS)},
  volume = {23},
  pages = {47--62},
  url = {https://www.microsoft.com/en-us/research/publication/trees-that-grow/},
  urldate = {2022-07-12},
  abstract = {We study the notion of extensibility in functional data types, as a new approach to the problem of decorating abstract syntax trees with additional information. We observed the need for such extensibility while redesigning the data types representing Haskell abstract syntax inside Glasgow Haskell Compiler (GHC). Specifically, we describe a programming idiom that exploits type-level […]},
  langid = {american},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Najd_Jones/2017/Najd_Jones_2017_Trees that grow.pdf}
}

@article{norellPracticalProgrammingLanguage,
  title = {Towards a Practical Programming Language Based on Dependent Type Theory},
  author = {Norell, Ulf},
  pages = {166},
  abstract = {Dependent type theories [ML72] have a long history of being used for theorem proving. One aspect of type theory which makes it very powerful as a proof language is that it mixes deduction with computation. This also makes type theory a good candidate for programming—the strength of the type system allows properties of programs to be stated and established, and the computational properties provide semantics for the programs.},
  langid = {english},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Norell/undefined/Norell_Towards a practical programming language based on dependent type theory.pdf}
}

@unpublished{selsamTabledTypeclassResolution2020,
  title = {Tabled {{Typeclass Resolution}}},
  author = {Selsam, Daniel and Ullrich, Sebastian and de Moura, Leonardo},
  options = {useprefix=true},
  date = {2020-01-21},
  number = {arXiv:2001.04301},
  eprint = {2001.04301},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.2001.04301},
  url = {http://arxiv.org/abs/2001.04301},
  urldate = {2022-06-07},
  abstract = {Typeclasses provide an elegant and effective way of managing ad-hoc polymorphism in both programming languages and interactive proof assistants. However, the increasingly sophisticated uses of typeclasses within proof assistants, especially within Lean's burgeoning mathematics library, mathlib, have elevated once-theoretical limitations of existing typeclass resolution procedures into major impediments to ongoing progress. The two most devastating limitations of existing procedures are exponential running times in the presence of diamonds and divergence in the presence of cycles. We present a new procedure, tabled typeclass resolution, that solves both problems by tabling, which is a generalization of memoizing originally introduced to address similar limitations of early logic programming systems. We have implemented our procedure for the upcoming version (v4) of Lean, and have confirmed empirically that our implementation is exponentially faster than existing systems in the presence of diamonds. Although tabling is notoriously difficult to implement, our procedure is notably lightweight and could easily be implemented in other systems. We hope our new procedure facilitates even more sophisticated uses of typeclasses in both software development and interactive theorem proving.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Selsam et al/2020/Selsam et al_2020_Tabled Typeclass Resolution.pdf;/home/bohdan/Zotero/storage/36ELAYLP/2001.html}
}

@article{serranoQuickLookImpredicativity2020,
  title = {A Quick Look at Impredicativity},
  author = {Serrano, Alejandro and Hage, Jurriaan and Peyton Jones, Simon and Vytiniotis, Dimitrios},
  date = {2020-08-02},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {4},
  pages = {89:1--89:29},
  doi = {10.1145/3408971},
  url = {https://doi.org/10.1145/3408971},
  urldate = {2022-07-04},
  abstract = {Type inference for parametric polymorphism is wildly successful, but has always suffered from an embarrassing flaw: polymorphic types are themselves not first class. We present Quick Look, a practical, implemented, and deployable design for impredicative type inference. To demonstrate our claims, we have modified GHC, a production-quality Haskell compiler, to support impredicativity. The changes required are modest, localised, and are fully compatible with GHC's myriad other type system extensions.},
  issue = {ICFP},
  keywords = {constraint-based inference,impredicative polymorphism,Type systems},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Serrano et al/2020/Serrano et al_2020_A quick look at impredicativity.pdf}
}

@inproceedings{stuckeyTypeProcessingConstraint2006,
  title = {Type {{Processing}} by {{Constraint Reasoning}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Stuckey, Peter J. and Sulzmann, Martin and Wazny, Jeremy},
  editor = {Kobayashi, Naoki},
  date = {2006},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {1--25},
  publisher = {{Springer}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/11924661_1},
  abstract = {Herbrand constraint solving or unification has long been understood as an efficient mechanism for type checking and inference for programs using Hindley/Milner types. If we step back from the particular solving mechanisms used for Hindley/Milner types, and understand type operations in terms of constraints we not only give a basis for handling Hindley/Milner extensions, but also gain insight into type reasoning even on pure Hindley/Milner types, particularly for type errors. In this paper we consider typing problems as constraint problems and show which constraint algorithms are required to support various typing questions. We use a light weight constraint reasoning formalism, Constraint Handling Rules, to generate suitable algorithms for many popular extensions to Hindley/Milner types. The algorithms we discuss are all implemented as part of the freely available Chameleon system.},
  isbn = {978-3-540-48938-2},
  langid = {english},
  keywords = {Functional Dependency,Type Class,Type Error,Type Processing,Typing Problem},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Stuckey et al/2006/Stuckey et al_2006_Type Processing by Constraint Reasoning.pdf}
}

@article{swierstraDataTypesCarte2008,
  title = {Data Types à La Carte},
  author = {Swierstra, Wouter},
  date = {2008-07},
  journaltitle = {Journal of Functional Programming},
  volume = {18},
  number = {4},
  pages = {423--436},
  publisher = {{Cambridge University Press}},
  issn = {1469-7653, 0956-7968},
  doi = {10.1017/S0956796808006758},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/data-types-a-la-carte/14416CB20C4637164EA9F77097909409},
  urldate = {2022-06-09},
  abstract = {This paper describes a technique for assembling both data types and functions from isolated individual components. We also explore how the same technology can be used to combine free monads and, as a result, structure Haskell's monolithic IO monad.},
  langid = {english},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Swierstra/2008/Swierstra_2008_Data types à la carte.pdf;/home/bohdan/Zotero/storage/USMDQ6VX/14416CB20C4637164EA9F77097909409.html}
}

@article{tassiBiDirectionalRefinementAlgorithm2012,
  title = {A {{Bi-Directional Refinement Algorithm}} for the {{Calculus}} of ({{Co}}){{Inductive Constructions}}},
  author = {Tassi, Enrico and Coen, Claudio Sacerdoti and Ricciotti, Wilmer and Asperti, Andrea},
  date = {2012-03-02},
  journaltitle = {Logical Methods in Computer Science},
  volume = {Volume 8, Issue 1},
  publisher = {{Episciences.org}},
  doi = {10.2168/LMCS-8(1:18)2012},
  url = {https://lmcs.episciences.org/1044/pdf},
  urldate = {2022-05-23},
  abstract = {The paper describes the refinement algorithm for the Calculus of (Co)Inductive Constructions (CIC) implemented in the interactive theorem prover Matita. The refinement algorithm is in charge of giving a meaning to the terms, types and proof terms directly written by the user or generated by using tactics, decision procedures or general automation. The terms are written in an "external syntax" meant to be user friendly that allows omission of information, untyped binders and a certain liberal use of user defined sub-typing. The refiner modifies the terms to obtain related well typed terms in the internal syntax understood by the kernel of the ITP. In particular, it acts as a type inference algorithm when all the binders are untyped. The proposed algorithm is bi-directional: given a term in external syntax and a type expected for the term, it propagates as much typing information as possible towards the leaves of the term. Traditional mono-directional algorithms, instead, proceed in a bottom-up way by inferring the type of a sub-term and comparing (unifying) it with the type expected by its context only at the end. We propose some novel bi-directional rules for CIC that are particularly effective. Among the benefits of bi-directionality we have better error message reporting and better inference of dependent types. Moreover, thanks to bi-directionality, the coercion system for sub-typing is more effective and type inference generates simpler unification problems that are more likely to be solved by the inherently incomplete higher order unification algorithms implemented. Finally we introduce in the external syntax the notion of vector of placeholders that enables to omit at once an arbitrary number of arguments. Vectors of placeholders allow a trivial implementation of implicit arguments and greatly simplify the implementation of primitive and simple tactics.},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Tassi et al/2012/Tassi et al_2012_A Bi-Directional Refinement Algorithm for the Calculus of (Co)Inductive.pdf}
}

@inproceedings{ullrichNotationsHygienicMacro2020a,
  title = {Beyond {{Notations}}: {{Hygienic Macro Expansion}} for {{Theorem Proving Languages}}},
  shorttitle = {Beyond {{Notations}}},
  booktitle = {Automated {{Reasoning}}},
  author = {Ullrich, Sebastian and de Moura, Leonardo},
  editor = {Peltier, Nicolas and Sofronie-Stokkermans, Viorica},
  options = {useprefix=true},
  date = {2020},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {167--182},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-030-51054-1_10},
  abstract = {In interactive theorem provers (ITPs), extensible syntax is not only crucial to lower the cognitive burden of manipulating complex mathematical objects, but plays a critical role in developing reusable abstractions in libraries. Most ITPs support such extensions in the form of restrictive “syntax sugar” substitutions and other ad hoc mechanisms, which are too rudimentary to support many desirable abstractions. As a result, libraries are littered with unnecessary redundancy. Tactic languages in these systems are plagued by a seemingly unrelated issue: accidental name capture, which often produces unexpected and counterintuitive behavior. We take ideas from the Scheme family of programming languages and solve these two problems simultaneously by proposing a novel hygienic macro system custom-built for ITPs. We further describe how our approach can be extended to cover type-directed macro expansion resulting in a single, uniform system offering multiple abstraction levels that range from supporting simplest syntax sugars to elaboration of formerly baked-in syntax. We have implemented our new macro system and integrated it into the upcoming version (v4) of the Lean theorem prover. Despite its expressivity, the macro system is simple enough that it can easily be integrated into other systems.},
  isbn = {978-3-030-51054-1},
  langid = {english},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Ullrich_de Moura/2020/Ullrich_de Moura_2020_Beyond Notations2.pdf}
}

@article{vytiniotisOutsideInModularType2011a,
  title = {{{OutsideIn}}({{X}}) {{Modular}} Type Inference with Local Assumptions},
  author = {Vytiniotis, Dimitrios and Jones, Simon Peyton and Schrijvers, Tom and Sulzmann, Martin},
  date = {2011-09},
  journaltitle = {Journal of Functional Programming},
  volume = {21},
  number = {4-5},
  pages = {333--412},
  publisher = {{Cambridge University Press}},
  issn = {1469-7653, 0956-7968},
  doi = {10.1017/S0956796811000098},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/outsideinx-modular-type-inference-with-local-assumptions/65110D74CF75563F91F9C68010604329},
  urldate = {2022-06-09},
  abstract = {Advanced type system features, such as GADTs, type classes and type families, have proven to be invaluable language extensions for ensuring data invariants and program correctness. Unfortunately, they pose a tough problem for type inference when they are used as local type assumptions. Local type assumptions often result in the lack of principal types and cast the generalisation of local let-bindings prohibitively difficult to implement and specify. User-declared axioms only make this situation worse. In this paper, we explain the problems and – perhaps controversially – argue for abandoning local let-binding generalisation. We give empirical results that local let generalisation is only sporadically used by Haskell programmers. Moving on, we present a novel constraint-based type inference approach for local type assumptions. Our system, called OutsideIn(X), is parameterised over the particular underlying constraint domain X, in the same way as HM(X). This stratification allows us to use a common metatheory and inference algorithm. OutsideIn(X) extends the constraints of X by introducing implication constraints on top. We describe the strategy for solving these implication constraints, which, in turn, relies on a constraint solver for X. We characterise the properties of the constraint solver for X so that the resulting algorithm only accepts programs with principal types, even when the type system specification accepts programs that do not enjoy principal types. Going beyond the general framework, we give a particular constraint solver for X = type classes + GADTs + type families, a non-trivial challenge in its own right. This constraint solver has been implemented and distributed as part of GHC 7.},
  langid = {english},
  file = {/home/bohdan/Downloads/Dropbox/stuff/papers/Vytiniotis et al/2011/Vytiniotis et al_2011_OutsideIn(X) Modular type inference with local assumptions2.pdf;/home/bohdan/Zotero/storage/JUWGNJ8V/65110D74CF75563F91F9C68010604329.html}
}


